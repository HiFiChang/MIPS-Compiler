.data
_str_lit_0: .asciiz "true\n"
_str_lit_1: .asciiz "false\n"
_newline: .asciiz "
"

.text
.globl main
copy:
    addiu $sp, $sp, -8  # Allocate space for old $fp and $ra
    sw $fp, 4($sp)      # Save old frame pointer
    sw $ra, 0($sp)      # Save return address
    addiu $fp, $sp, 4   # Set up new frame pointer (points to saved old $fp)
    addiu $sp, $sp, -4  # Allocate space for locals and temps
    # MIPS_DEBUG: Processing params for func: copy
    # Step 1: Secure stack-passed parameters by moving them to final slots
    # Step 2: Store register-passed parameters to their final slots
    sw $a0, 4($fp)  # Store register param 'n' (from $a0) to its designated stack slot
    lw $v0, 4($fp)       # Load from __copy_n_s2 (4($fp))
    j _L_copy_epilogue # Jump to epilogue on return val
_L_copy_epilogue:
    move $sp, $fp
    lw $ra, -4($sp)
    lw $fp, 0($sp)
    addiu $sp, $sp, 4
    jr $ra

main:
    addiu $sp, $sp, -8  # Allocate space for old $fp and $ra
    sw $fp, 4($sp)      # Save old frame pointer
    sw $ra, 0($sp)      # Save return address
    addiu $fp, $sp, 4   # Set up new frame pointer (points to saved old $fp)
    addiu $sp, $sp, -28  # Allocate space for locals and temps
    li $t8, 1       # Load immediate 1
    move $a0, $t8  # Param 0 ('1') to $a0
    jal copy         # Call function copy
    sw $v0, -8($fp)
    li $t8, 1       # Load immediate 1
    move $a0, $t8  # Param 0 ('1') to $a0
    jal copy         # Call function copy
    sw $v0, -12($fp)
    lw $t0, -8($fp)       # Load from _t0 (-8($fp))
    lw $t1, -12($fp)       # Load from _t1 (-12($fp))
    seq $t2, $t0, $t1
    sw $t2, -16($fp)
    lw $t0, -16($fp)       # Load from _t2 (-16($fp))
    beq $t0, $zero, _L0  # If _t2 is false (zero), goto _L0
    li $v0, 4
    la $a0, _str_lit_0
    syscall
    j _L1
_L0:
    li $v0, 4
    la $a0, _str_lit_1
    syscall
_L1:
    li $t8, 2       # Load immediate 2
    move $a0, $t8  # Param 0 ('2') to $a0
    jal copy         # Call function copy
    sw $v0, -20($fp)
    li $t8, 3       # Load immediate 3
    move $a0, $t8  # Param 0 ('3') to $a0
    jal copy         # Call function copy
    sw $v0, -24($fp)
    lw $t0, -20($fp)       # Load from _t3 (-20($fp))
    lw $t1, -24($fp)       # Load from _t4 (-24($fp))
    seq $t2, $t0, $t1
    sw $t2, -28($fp)
    lw $t0, -28($fp)       # Load from _t5 (-28($fp))
    beq $t0, $zero, _L2  # If _t5 is false (zero), goto _L2
    li $v0, 4
    la $a0, _str_lit_0
    syscall
    j _L3
_L2:
    li $v0, 4
    la $a0, _str_lit_1
    syscall
_L3:
    li $v0, 0       # Load immediate 0
    j _L_main_epilogue # Jump to epilogue on return val
_L_main_epilogue:
    move $sp, $fp
    lw $ra, -4($sp)
    lw $fp, 0($sp)
    addiu $sp, $sp, 4
    li $v0, 10
    syscall

